<x:main>
    <h1>Developing Mininim</h1>
    <section class="prose">
        <section class="intro">
            <p>
                <a href="https://github.com/mattsah/mininim">Mininim</a> is a general purpose application framework and library for Nim.  Development started in early 2025 while I was still working at Jobs for the Future (JFF) and came out of personal research into high-performance options for REST APIs and microservices.  Nim was chosen primarily for its comprehensive meta-programming features which enable the development of small DSLs and custom patterns that further enable extremely rapid development and prototyping.
            </p>
            <p>
                Investigation and development was re-ignited in the fall of 2025 to help fill future needs related to <a href="https://primd.app">Primd</a> with the project being officially transferred in December.  Though specific features will be prioritized around Primd's use cases, the general goals remain largely the same:
            </p>
            <ul>
                <li>Component-based server-side dynanmic templating for integration with <a href="https://htmx.org/">HTMX</a> and <a href="https://alpinejs.dev/">AlpineJS</a>.</li>
                <li>Easy addition of new routes and commands via local behavior.</li>
                <li>Extensibile and modular design for a la carte feature requirements.</li>
            </ul>
            <p>
                This site, uses Mininim's dynamic templating and "pages" middleware (modeled after <a href="https://hiraeth.dev">Hiraeth</a>) to provide a simple portfolio solution while forwarding development via a real-world use case.  Below is a list of features and a preview into how it looks to develop in Mininim.
            </p>
        </section>
        <x class:="my-4">
            <section>
                <h2>Pages Middleware</h2>
                <x:code:sample>
                    <x:code :esc type="nim">
                        import
                            dotenv,
                            mininim/loader,
                            mininim/dic,
                            mininim/cli,
                            mininim/mdlw/pages

                        if os.fileExists(".env"):
                            dotenv.load()

                        loader.scan("./local")

                        var
                            app = App.init()
                            console = app.get(Console)

                        quit(console.run())
                    </x:code>
                    <div>
                        <p>
                            The "pages" middleware is designed to allow direct to template routing based simple directory structure.  You can think of it as something of a return to static HTML files with the primary caveat being that you have the full power of the templating language.  Addint the functionality to a standard Mininim application is as simple <code>import mininim/mdlw/pages</code> with the <code>mininim/web</code> package installed.
                        </p>
                        <x:code:sample>
                            <p>
                                Within the pages module, the middleware is automatically registered via Mininim's unique <code>shape</code> directive.  By importing the middleware, the application will also import the requisite CLI command to start the HTTP Server.
                            </p>
                            <x:code :esc type="nim">
                                shape Pages: @[
                                    Middleware(
                                        name: "pages",
                                        priority: 900
                                    )
                                ]
                            </x:code>
                        </x:code:sample>
                    </div>
                </x:code:sample>
            </section>
            <section>
                <h2>Adding Pages and Components</h2>
                <x:code:sample>
                    <p>
                        Adding a page is as simple as adding a file starting with an <code>@</code> symbol to the <code>resources/pages</code> directory.  For example, we could add the following to <code>resources/pages/@index.html</code> to create our initial landing page.
                    </p>
                    <x:code :esc type="twig">
                        <x:main>
                            <h1>Hello World!</h1>
                        </x:main>
                    </x:code>
                </x:code:sample>
                <x:code:sample>
                    <p>
                        This particular example, however, won't work until we've defined our <code>&lt;x:main&gt;</code> tag in <code>resources/tags/main.html</code>.  In this example, our custom component includes the overall site structure.  Note the use of the <code>&lt;raw&gt;</esc></code> tag, which enables the content of our <code><esc>{{ children }}</esc></code> to be parsed and rendered as if it were part of the original DOM.  As you've probably inferred, an <code>&lt;x:*&gt;</code> tag maps to files located in the <code>resources/tags</code> directory.  All subsequent <code>:</code> are converted to <code>/</code> allowing for comprehensive nesting/namespacing support.
                    </p>
                    <x:code :esc type="twig" class:="order-first">
                        <html>
                            <head>
                                <meta charset="UTF-8" />
                                <title>
                                    {{ title ? "Matthew Sahagian : Portfolio" }}
                                </title>
                            </head>
                            <body class="max-w-6xl mx-auto">
                                <raw>
                                     {{ children }}
                                </raw>
                            </body>
                        </html>
                    </x:code>
                </x:code:sample>
            </section>
            <section>
                <h3>Component Scope</h3>
                <x:code:sample>
                    <p>
                        Components have an isolated scope.  This means that whenever you call a component from another template, the only variables available within that component are those that are passed by attributes to the component.  For example, the <code>name</code> variable is not directly available in the component or to the children, but the <code>title</code> variable will be.
                    </p>
                    <x:code :esc type="twig">
                        <set name="Bob" />
                        <x:main title="The Spy Who Awked Me">
                            <h1>
                                Hello {{ name ? "World" }}!
                            </h1>
                        </x:main>
                    </x:code>
                </x:code:sample>
                <x:code:sample>
                    <p>
                        You can, however, access external scope via the <code>context</code> object or by passing the requisite data in as an attribute.
                    </p>
                    <x:code :esc type="twig">
                        <set name="Bob" />
                        <x:main title="The Spy Who Awked Me">
                            <h1>
                                Hello {{ context.name ? "World" }}!
                            </h1>
                        </x:main>
                    </x:code>
                    <x:code :esc type="twig">
                        <set name="Bob" />
                        <x:main title="The Spy Who Awked Me" name:val="name">
                            <h1>
                                Hello {{ name ? "World" }}!
                            </h1>
                        </x:main>
                    </x:code>
                </x:code:sample>
            </section>
            <section>
                <h3>Merge Attributes and Fragments</h3>
                <x:code:sample>
                    <div>
                        <p>
                            When working with components, it's common to need to add attributes to the underlying element(s) they represent.  This is most common for the <code>class</code> attribute, but with HTMX and AlpineJS it can useful for many more examples.
                        </p>
                        <p>
                            Merge attributes can be used on any <code>&lt;x&gt;</code> style element and end with a <code>:</code> to distinguish them from actual component attributes.  The <code>:</code> is stripped and the content is merged into all top-level children's attributes by the same name.
                        </p>
                    </div>
                    <div class="order-first" x-data>
                        <x class:="mb-2">
                            <p>
                                Example component <code>resources/tags/button.html</code>:
                            </p>
                            <x:code :esc type="twig">
                                <button class="px-4 py-1 rounded-md bg-white/8 text-coral cursor-pointer">
                                    <raw>
                                        {{ children ? text }}
                                    </raw>
                                </button>
                            </x:code>
                            <p>
                                Used with merge attributes:
                            </p>
                            <x:code :esc type="twig">
                                <x:button x-on:click:="alert('Hello Mininim!')" text="Click Me!" />
                            </x:code>
                            <p>
                                Result:
                            </p>
                            <x:button x-on:click:="alert('Hello Mininim!')" text="Click Me!" />
                        </x>
                    </div>
                </x:code:sample>
                <x:code:sample>
                    <p>
                        In addition to components like <code>&lt;x:button&gt;</code>, it's also possible to use the <code>&lt;x&gt;</code> tag with no path.  When used like this, it acts as an "invisible" fragment wrapper which is not, itself, inserted in the DOM.  Its children, however, will be inserted in its place.  Combining this with merge attributes, we can see some immediate utility for easily applying common attributes across multiple elements.
                    </p>
                    <x:code :esc type="twig">
                        <x class:="bg-white/10 p-4 my-6">
                            <p>
                                Each of these child paragraphs will have the class attribute.
                            </p>
                            <p>
                                But just as with components, only the top-level children.
                            </p>
                            <p>
                                Not <span>this span tag</span> or any subsequent children.
                            </p>
                        </x>
                    </x:code>
                </x:code:sample>
            </section>
        </x>
    </section>
</x:main>
